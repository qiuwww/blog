
## HTML页面的加载和解析流程

HTML页面加载和解析流程 

1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。 

2. 浏览器开始载入html代码，发现<head>标签内有一个<link>标签引用外部CSS文件。 

3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件。 

4. 浏览器继续载入html中<body>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。 

5. 浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。 

6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。 

7. 浏览器发现了一个包含一行Javascript代码的<script>标签，赶快运行它。 

8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个<style>（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。 

9. 终于等到了</html>的到来，浏览器泪流满面…… 

10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径。 

11. 浏览器召集了在座的各位<div><span><ul><li>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。

## 从输入 URL 到浏览器接收的过程中发生了什么事情


### 输入

键盘、鼠标、触摸屏 -> 转换到电气信号电路 -> cpu|gpu

## 浏览器如何向网卡发送数据

输入 URL 后的「回车」，这时浏览器会对 URL 进行检查，首先判断协议，如果是 http 就按照 Web 来处理，另外还会对这个 URL 进行安全检查，然后直接调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法。

> 输入 URL 后的「回车」，这时浏览器会对 URL 进行检查，首先判断协议，如果是 http 就按照 Web 来处理，另外还会对这个 URL 进行安全检查，然后直接调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法。

### http请求的发送

因为网络的底层实现是和内核相关的，所以这一部分需要针对不同平台进行处理，从**应用层角度看主要做两件事情：通过 DNS 查询 IP、通过 Socket 发送数据。**

#### DNS查询

**DNS(domain name system)**，读者们或多或少都听过，就是可以**将域名转换给IP的一个系统**。使得我们**只需记住域名而非IP就能访问某个网站**。

- 当我们在浏览器里面输入一个网址时，浏览器会向本地DNS服务器发出查询请求，本地DNS服务器会把网址对应的IP返回给浏览器。注意：更确切来说，不是本地DNS服务器，而是Windows网络连接里面所配置的DNS服务器。一般我们不会配置的，所以本文默认使用**本地DNS服务器**。
- **也可以更改域名ip指向，直接指向要访问的服务器的ip。**

### 通过socket发送数据

有了 IP 地址，就可以通过 Socket API 来发送数据了，这时可以选择 TCP 或 UDP 协议。

因为 HTTP pipelining 可以让多个 HTTP 请求通过一个 TCP 发送。







1. 解析HTML，构建DOM树（这里遇到外链，此时会发起请求）
2. 解析CSS，生成CSS规则树
3. 合并DOM树和CSS规则，生成render树
4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
5. 绘制render树（paint），绘制页面像素信息
6. 浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上

